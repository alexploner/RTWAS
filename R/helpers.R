#' Identify incorrectly coded and reversed alleles
#'
#' When comparing effect / reference alleles for vectors of SNPs from two sources,
#' identify a. SNPs that are either not ACGT or strand-ambiguous, b. where effect
#' / reference allele have been reversed between sources.
#'
#' @param a1,a2 vectors of effect / reference allele from first source
#' @param ref1,ref2 vectors of effect / reference alleles from second source
#'                  (implied: the reference, but not necessary)
#'
#' @returns A list with two logical vectors, each of the same length as the
#'          put vectors: `keep` indicating SNPs that have valid coding and are
#'          not strand-ambiguous, and `flip` indicating SNPs with reversed
#'          effect / reference definition between sources.
#'
#' @export
allele.qc = function(a1,a2,ref1,ref2)
{
  ## FIXME: check vector lengths, NAs?
  a1 = toupper(a1)
  a2 = toupper(a2)
  ref1 = toupper(ref1)
  ref2 = toupper(ref2)

  ## FIXME: de-duplicate code
  ref  = ref1
  flip = ref
  flip[ref == "A"] = "T"
  flip[ref == "T"] = "A"
  flip[ref == "G"] = "C"
  flip[ref == "C"] = "G"
  flip1 = flip

  ref = ref2
  flip = ref
  flip[ref == "A"] = "T"
  flip[ref == "T"] = "A"
  flip[ref == "G"] = "C"
  flip[ref == "C"] = "G"
  flip2 = flip

  snp = list()

  ## Do not keep SNPs that are distinct biological variants, but may be just
  ## complementary (strand-ambiguous)
  snp[["keep"]] = !( (a1=="A" & a2=="T") | (a1=="T" & a2=="A") |
                     (a1=="C" & a2=="G") | (a1=="G" & a2=="C") )
  ## Do not keep SNPs that are not clean single-nucleotide variants
  snp[["keep"]][ a1 != "A" & a1 != "T" & a1 != "G" & a1 != "C" ] = FALSE
  snp[["keep"]][ a2 != "A" & a2 != "T" & a2 != "G" & a2 != "C" ] = FALSE

  ## Flipped variants when there is cross-allele agreement between sources
  snp[["flip"]] = (a1 == ref2 & a2 == ref1) | (a1 == flip2 & a2 == flip1)

  snp
}

#' Read list of genes with TWAS z-statistics
#'
#' Read the output file with the gene-level TWAS statistics as generated by
#' script FUSION.assoc_test.R for further testing / conditional TWAS.
#'
#' @param file Name of the file with gene names
#' @param chr Number of chromosome to use for filtering (`NA` for no filtering)
#' @param minp Minimal significance level required to be included (`NA` for no filtering)
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @returns A data frame with rows as genes and columns containing gene information
#' and TWAS results FIXME: more details
#'
#' @export
read_genelist <- function(file, chr, minp, opts = opts_rtwas$get())
{
  ## Use options to fill in missing values
  if (missing(file)) file <- opts[["input"]]
  if (missing(chr))  chr  <- opts[["chr"]]
  if (missing(minp)) minp <- opts[["minp_input"]]

  ## Read specified file
  genes <- read.table(file, as.is = TRUE, head = TRUE)

  ## FIXME: more checks could not hurt
  stopifnot( "TWAS.P" %in% colnames(genes) )
  stopifnot( "CHR"    %in% colnames(genes) )

  ## Cut down to chromosome, non-missing and small enough p-values, if required
  if (!is.na(chr))  genes <- genes[ genes$CHR == chr, ]
  if (!is.na(minp)) genes <- genes[ (genes$TWAS.P <  minp) & !is.na(genes$TWAS.P), ]

  genes
}

#' Read genetic reference data
#'
#' Read the genetic reference data for establishing LD estimates etc.
#'
#' @param file Stub of the file names containing the reference data, see Details.
#' @param chr Number of chromosome to read in
#' @param scale Logical flag indicating whether to scale the allele counts
#'              (default `TRUE`)
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @details The reference data is assumed to be in PLINK format (.bed/.bim/.fam),
#' with file names as `<stub>.<chr number>.<ext>`. The standard data used by
#' FUSION is the European subset of the 1000 Genomes data.
#'
#' @returns FIXME
#'
#' @export
read_refdata <- function(file, chr, scale = TRUE, opts = opts_rtwas$get())
{
  ## Use options to fill in missing values
  if (missing(file)) file <- opts[["ref_ld_chr"]]
  stopifnot( !is.na(file) )
  if (missing(chr))  chr  <- opts[["chr"]]
  stopifnot( !is.na(chr) )
  ## Combine for chr-specific stub
  file <- paste0(file, chr)

  ## Read the specified file(s)
  refdat <- plink2R::read_plink(file, impute="avg")
  ## Column names for bim are useful
  colnames(refdat$bim) <- c("CHR", "SNPID", "POS", "BP", "A1", "A2")
  ## FIXME: colnames fam as per https://www.cog-genomics.org/plink2/formats#fam

  if (scale) refdat$bed <- scale(refdat$bed)

  refdat
}

## Load the content of a .RData file to a list, as per
## https://stackoverflow.com/questions/61384955/load-rdata-file-into-list
##
## Somewhat memory intense (especially nested in a function call), but the
## size of the data loaded here (pre-calculated weights) is trivial
load2list <- function(file)
{
  load(file,  temp_env <- new.env())
  as.list(temp_env)
}

## Calculate the correlation matrix for the predicted gene expression
## values from the matrix of predicted gene expressions, as
## returned by predict_expression
##
## Trivial, but wrapped to include shrinking low correlations to zero,
## and checking for positive definiteness of the shrunk matrix
#' @export
calcCorr_predGE <- function(pred_ge, opts = opts_rtwas$get())
{
  ## Calculate
  corr <- cor(pred_ge)

  ## Shrink small correlations
  ndx <- corr*corr < opts$min_r2
  if (any(ndx)) cat(length(which(ndx)), "/", nrow(corr)^2,
                     " correlations between gene expression shrunk\n", sep="")
  corr[ndx] <- 0
  ## Check pos-def
  if (prod(svd(corr)$d) <= 0) cat("Shrunk matrix is not pos-semidefinite\n")

  corr
}

#' Identify contiguous loci around EQTL-SNPs in the genetic reference data
#'
#' For the conditional TWAS analysis, both the SNPs and the conditioning
#' (gene-level) TWAS-statistics are clumped into contiguous loci.
#'
#' @param refdata Genetic reference data, as a list with PLINK-style components;
#'                typically output from `read_refdata`
#' @param snp_ndx logical vector indicating for each SNP in the reference data
#'                whether it carries an EQTL weight (and is therefore included
#'                in the locus-construction); typically output from `eqtl_to_refdat`.
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @return A data frame with columns `starts` and `ends` indicating the start and
#'         end base pair position of each locus
#'
#' @seealso [read_refdata()], [eqtl_to_refdat()]
#' @export
find_loci <- function(refdata, snp_ndx, opts = opts_rtwas$get())
{
  ## Quick check: can this be the correct index?
  stopifnot(nrow(refdata$bim) == length(snp_ndx))

  ## Identify consecutive sequences of EQTL SNPs
  runs     <- rle(snp_ndx)
  runs_end <- cumsum(runs$lengths)
  if ( runs$val[1] ) { ## Starting on an eqtl SNP (TRUE)
    loc.starts <- c(1, runs_end[!runs$val] + 1)
  } else { ## Starting with non-eqtl SNP (FALSE)
    loc.starts <- runs_end[ !runs$val ] + 1
  }
  loc.ends   <- runs_end[runs$val]
  loc.starts <- loc.starts[ 1:length(loc.ends) ]

  ## Translate the SNP-index into the actual BP address of the start / end, and
  ## extend by the specified number of BP in both directions
  loc.starts <- refdata$bim[loc.starts, "BP"] - opts$locus_win
  loc.ends   <- refdata$bim[loc.ends, "BP"]   + opts$locus_win
  if( opts$verbose > 0 ) {
    cat( length(loc.starts) , " strictly non-overlapping loci\n" , sep='' , file=stderr() )
  }

  ## Now with the extended BP window, some of the loci may actually overlap, so
  ## these are combined here
  cons.loc.starts <- loc.starts[1]
  cons.loc.ends   <- loc.ends[1]
  loc.ctr <- 1

  ## Only if we have more than one locus, actually
  if ( length(loc.starts) > 1 ) {

    for ( i in 2:length(loc.starts) ) {
      if ( loc.starts[i] < cons.loc.ends[ loc.ctr ] ) {
        cons.loc.ends[ loc.ctr ] <- max( cons.loc.ends[ loc.ctr ], loc.ends[i] )
      } else {
        ## Not super-efficient extending the vector, but ok
        cons.loc.starts <- c(cons.loc.starts, loc.starts[i])
        cons.loc.ends   <- c(cons.loc.ends, loc.ends[i])
        loc.ctr <- loc.ctr + 1
      }
    }

  }

  if( opts$verbose > 0 ) {
    cat( "consolidated to ", length(cons.loc.starts) , " non-overlapping loci with ",
         opts$locus_win , " bp buffer\n" , sep='' , file=stderr() )
  }

  data.frame(starts = cons.loc.starts, ends = cons.loc.ends)
}

## Set default treshold for TWAS relevance
##
## Following FUSION, this is somewhat complicated (and error-prone): if it
## evaluates logically to TRUE, use the specified value evaluated as numerical
## expression; if it evaluates as FALSE, the value is set to 0.05/#genes (i.e.
## a Bonferroni-adjusted threshold of 0.05)
set_zthresh <- function(ngenes, opts = opts_rtwas$get())
{
  if( opts$zthresh ) {
    zthresh <- as.numerical( opts$zthresh )
  } else {
    zthresh <- qnorm( 0.025/ ngenes , lower.tail=FALSE)
  }

  if( opts$verbose > 1 ) {
    cat( ngenes , " weights considered, only weights with Z^2 > ", zthresh^2 ,
         " are retained in the model\n" , sep='' , file=stderr() )
  }

  zthresh
}

#' Read GWAS summary statistics
#'
#' Read the summary statistics for the phenotype of interest
#'
#' @param refdata Genetic reference data, as a list with PLINK-style components;
#'                typically output from `read_refdata`
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @details data format FIXME
#'
#' @returns FIXME
#'
#' @export
read_sumstats <- function(refdata, opts = opts_rtwas$get())
{

  sumstat <- read.table(opts$sumstats, head=TRUE, as.is=TRUE)

  ## Cut down the summary stats to what is currently being analyzed
  ## - keeping the non-matched SNPs by filling in name & alleles, with NA for
  ##   actual summary stats
  m <- match( refdata$bim[,2] , sumstat$SNP )
  sum.missing <- is.na(m)
  sumstat <- sumstat[m,]
  sumstat$SNP = refdata$bim[,2]
  sumstat$A1[ sum.missing ] = refdata$bim[sum.missing,5]
  sumstat$A2[ sum.missing ] = refdata$bim[sum.missing,6]

  # QC / allele-flip the input and output
  qc <- allele.qc( sumstat$A1 , sumstat$A2 , refdata$bim[,5] , refdata$bim[,6] )

  # Flip Z-scores for mismatching alleles
  sumstat$Z[ qc$flip ]  <- -1 * sumstat$Z[ qc$flip ]
  sumstat$A1[ qc$flip ] <- refdata$bim[qc$flip,5]
  sumstat$A2[ qc$flip ] <- refdata$bim[qc$flip,6]

  sumstat
}

#' Hg19 gene list for annotation
#'
#' A dataset containing the Hg19 build of the humna genome for annotating
#' GWAS/TWAS SNP-level results.
#'
#' @format A data frame with 26,292 rows and four variables:
#' \describe{
#'   \item{CHR}{chromosome where gene is located}
#'   \item{P0}{first base position}
#'   \item{P1}{last base position}
#'   \item{ID}{name of gene}
#' }
#' @source Part of the original FUSION software \url{https://github.com/gusevlab/fusion_twas}
"genelist"

#' Expand file names
#'
#' Replace special string `!!!!` with the number of the chromosomes to be
#' processed in file name templates
#'
#' @param template character vector with template or file names
#' @param chr a numerical vector of chromosome numbers (range 1-22)
#'
#' @returns A character vector of file names, expanded if the input `template`
#' contained the special `!!!!`, otherwise the original input
#' @export
#' @examples
#' expand_special("sumstats_chr!!!!", 1:22)
#' expand_special("sumstats_wholeGenome", 1:22)
#' expand_special(c("sumstats_chr1", "sumstats_chr2"), 1:2)
expand_special <- function(template, chr)
{
  ## Check & prepare the chromosome
  nchr <- length(chr)
  stopifnot( nchr > 0 )
  if (is.numeric(chr)) {
    chr <- round(chr)
    stopifnot( (1<=chr) & (chr <=22) )
  } else if (is.character(chr)) {
    stopifnot( all(chr %in% as.character(1:22)))
  }
  stopifnot( !any(is.na(chr)) )

  lt <- length(template)
  stopifnot( lt > 0)
  ## We only process templates of length one, anything else is passed through
  ## if its length matches the number of chromosomes
  if (lt > 1) {
    stopifnot( lt == nchr)
    fn <- template
  } else {
    ## If no special is specified in the template, we just replicate the
    ## input
    if ( grepl("!!!!", template, fixed = TRUE) ) {
      fn <- sapply(chr, function(x) gsub("!!!!", x, template, fixed = TRUE))
    } else {
      fn <- rep(template, nchr)
    }
  }

  fn
}
