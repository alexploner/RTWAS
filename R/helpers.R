#' Identify incorrectly coded and reversed alleles
#'
#' When comparing effect / reference alleles for vectors of SNPs from two sources,
#' identify a. SNPs that are either not ACGT or strand-ambiguous, b. where effect
#' / reference allele have been reversed between sources.
#'
#' @param a1,a2 vectors of effect / reference allele from first source
#' @param ref1,ref2 vectors of effect / reference alleles from second source
#'                  (implied: the reference, but not necessary)
#'
#' @returns A list with two logical vectors, each of the same length as the
#'          put vectors: `keep` indicating SNPs that have valid coding and are
#'          not strand-ambiguous, and `flip` indicating SNPs with reversed
#'          effect / reference definition between sources.
#'
#' @export
allele.qc = function(a1,a2,ref1,ref2)
{
  ## FIXME: check vector lengths, NAs?
  a1 = toupper(a1)
  a2 = toupper(a2)
  ref1 = toupper(ref1)
  ref2 = toupper(ref2)

  ## FIXME: de-duplicate code
  ref  = ref1
  flip = ref
  flip[ref == "A"] = "T"
  flip[ref == "T"] = "A"
  flip[ref == "G"] = "C"
  flip[ref == "C"] = "G"
  flip1 = flip

  ref = ref2
  flip = ref
  flip[ref == "A"] = "T"
  flip[ref == "T"] = "A"
  flip[ref == "G"] = "C"
  flip[ref == "C"] = "G"
  flip2 = flip

  snp = list()

  ## Do not keep SNPs that are distinct biological variants, but may be just
  ## complementary (strand-ambiguous)
  snp[["keep"]] = !( (a1=="A" & a2=="T") | (a1=="T" & a2=="A") |
                     (a1=="C" & a2=="G") | (a1=="G" & a2=="C") )
  ## Do not keep SNPs that are not clean single-nucleotide variants
  snp[["keep"]][ a1 != "A" & a1 != "T" & a1 != "G" & a1 != "C" ] = FALSE
  snp[["keep"]][ a2 != "A" & a2 != "T" & a2 != "G" & a2 != "C" ] = FALSE

  ## Flipped variants when there is cross-allele agreement between sources
  snp[["flip"]] = (a1 == ref2 & a2 == ref1) | (a1 == flip2 & a2 == flip1)

  snp
}

#' Read list of genes with TWAS z-statistics
#'
#' Read the output file with the gene-level TWAS statistics as generated by
#' script FUSION.assoc_test.R for further testing / conditional TWAS.
#'
#' @param file Name of the file with gene names
#' @param chr Number of chromosome to use for filtering (`NA` for no filtering)
#' @param minp Minimal significance level required to be included (`NA` for no filtering)
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @returns A data frame with rows as genes and columns containing gene information
#' and TWAS results FIXME: more details
#'
#' @export
read_genelist <- function(file, chr, minp, opts = opts_rtwas$get())
{
  ## Use options to fill in missing values
  if (missing(file)) file <- opts[["input"]]
  if (missing(chr))  chr  <- opts[["chr"]]
  if (missing(minp)) minp <- opts[["minp_input"]]

  ## Read specified file
  genes <- read.table(file, as.is = TRUE, head = TRUE)

  ## FIXME: more checks could not hurt
  stopifnot( "TWAS.P" %in% colnames(genes) )
  stopifnot( "CHR"    %in% colnames(genes) )

  ## Cut down to chromosome, non-missing and small enough p-values, if required
  if (!is.na(chr))  genes <- genes[ genes$CHR == chr, ]
  if (!is.na(minp)) genes <- genes[ (genes$TWAS.P <  minp) & !is.na(genes$TWAS.P), ]

  genes
}

#' Read genetic reference data
#'
#' Read the genetic reference data for establishing LD estimates etc.
#'
#' @param file Stub of the file names containing the reference data, see Details.
#' @param chr Number of chromosome to read in
#' @param scale Logical flag indicating whether to scale the allele counts
#'              (default `TRUE`)
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @details The reference data is assumed to be in PLINK format (.bed/.bim/.fam),
#' with file names as `<stub>.<chr number>.<ext>`. The standard data used by
#' FUSION is the European subset of the 1000 Genomes data.
#'
#' @returns FIXME
#'
#' @export
read_refdata <- function(file, chr, scale = TRUE, opts = opts_rtwas$get())
{
  ## Use options to fill in missing values
  if (missing(file)) file <- opts[["ref_ld_chr"]]
  stopifnot( !is.na(file) )
  if (missing(chr))  chr  <- opts[["chr"]]
  stopifnot( !is.na(chr) )
  ## Combine for chr-specific stub
  file <- paste0(file, chr)

  ## Read the specified file(s)
  refdat <- plink2R::read_plink(file, impute="avg")
  ## Column names for bim are useful
  colnames(refdat$bim) <- c("CHR", "SNPID", "POS", "BP", "A1", "A2")
  ## FIXME: colnames fam as per https://www.cog-genomics.org/plink2/formats#fam

  if (scale) refdat$bed <- scale(refdat$bed)

  refdat
}

## Load the content of a .RData file to a list, as per
## https://stackoverflow.com/questions/61384955/load-rdata-file-into-list
##
## Somewhat memory intense (especially nested in a function call), but the
## size of the data loaded here (pre-calculated weights) is trivial
load2list <- function(file)
{
  load(file,  temp_env <- new.env())
  as.list(temp_env)
}

## Calculate the correlation matrix for the predicted gene expression
## values from the matrix of predicted gene expressions, as
## returned by predict_expression
##
## Trivial, but wrapped to include shrinking low correlations to zero,
## and checking for positive definiteness of the shrunk matrix
calcCorr_predGE <- function(predge, opts = opts_rtwas$get())
{
  ## Calculate
  corr <- cor(pred_ge)

  ## Shrink small correlations
  ndx <- corr*corr < opts$min_r2
  if (any(ndx)) cat(length(which(ndx)), "/", nrow(corr)^2,
                     " correlations between gene expression shrunk\n", sep="")
  corr[ndx] <- 0
  ## Check pos-def
  if (prod(svd(corr)$d) <= 0) cat("Shrunk matrix is not pos-semidefinite\n")

  corr
}

#' Identify contiguous loci around EQTL-SNPs in the genetic reference data
#'
#' For the conditional TWAS analysis, both the SNPs and the conditioning
#' (gene-level) TWAS-statistics are clumped into contiguous loci.
#'
#' @param refdata Genetic reference data, as a list with PLINK-style components;
#'                typically output from `read_refdata`
#' @param snp_ndx logical vector indicating for each SNP in the reference data
#'                whether it carries an EQTL weight (and is therefore included
#'                in the locus-construction); typically output from `eqtl_to_refdat`.
#' @param opts List of options used for extracting default values for unspecified
#'             arguments
#'
#' @return A data frame with columns `starts` and `ends` indicating the start and
#'         end base pair position of each locus
#'
#' @seealso [read_refdata()], [eqtl_to_refdat()]
#' @export
find_loci <- function(refdata, snp_ndx, opts = opts_rtwas$get())
{
  ## Quick check: can this be the correct index?
  stopifnot(nrow(refdata$bim) == length(snp_ndx))

  ## Identify consecutive sequences of EQTL SNPs
  runs     <- rle(snp_ndx)
  runs_end <- cumsum(runs$lengths)
  if ( runs$val[1] ) { ## Starting on an eqtl SNP (TRUE)
    loc.starts <- c(1, runs_end[!runs$val] + 1)
  } else { ## Starting with non-eqtl SNP (FALSE)
    loc.starts <- runs_end[ !runs$val ] + 1
  }
  loc.ends   <- runs_end[runs$val]
  loc.starts <- loc.starts[ 1:length(loc.ends) ]

  ## Translate the SNP-index into the actual BP address of the start / end, and
  ## extend by the specified number of BP in both directions
  loc.starts <- refdata$bim[loc.starts, "BP"] - opts$locus_win
  loc.ends   <- refdata$bim[loc.ends, "BP"]   + opts$locus_win
  if( opts$verbose > 0 ) {
    cat( length(loc.starts) , " strictly non-overlapping loci\n" , sep='' , file=stderr() )
  }

  ## Now with the extended BP window, some of the loci may actually overlap, so
  ## these are combined here
  cons.loc.starts <- loc.starts[1]
  cons.loc.ends   <- loc.ends[1]
  loc.ctr <- 1

  ## Only if we have more than one locus, actually
  if ( length(loc.starts) > 1 ) {

    for ( i in 2:length(loc.starts) ) {
      if ( loc.starts[i] < cons.loc.ends[ loc.ctr ] ) {
        cons.loc.ends[ loc.ctr ] <- max( cons.loc.ends[ loc.ctr ], loc.ends[i] )
      } else {
        ## Not super-efficient extending the vector, but ok
        cons.loc.starts <- c(cons.loc.starts, loc.starts[i])
        cons.loc.ends   <- c(cons.loc.ends, loc.ends[i])
        loc.ctr <- loc.ctr + 1
      }
    }

  }

  if( opts$verbose > 0 ) {
    cat( "consolidated to ", length(cons.loc.starts) , " non-overlapping loci with ",
         opts$locus_win , " bp buffer\n" , sep='' , file=stderr() )
  }

  data.frame(starts = cons.loc.starts, ends = cons.loc.ends)
}

